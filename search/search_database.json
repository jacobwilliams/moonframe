var tipuesearch = {"pages":[{"title":" moonframe ","text":"moonframe Description A Fortran library to interpolate the MOON_PA reference frame without using SPICE. Description The MOON_PA reference frame is a high-accuracy Moon body-fixed frame. This library provides a means to use this frame without having to load SPICE kernels. This is done by splining a table of precomputed roll, pitch, and yaw values. These values are used to compute the rotating matrix from J2000 to the frame. This package also provides the code for generating these tables using SPICELIB. Usage To generate the files and run the tests, this requires SPICELIB to be present and the HAS_SPICELIB directive to be set. To generate the coefficient files: fpm run generate -- profile release -- flag \"-D HAS_SPICELIB\" -- link - flag \"./toolkit/lib/spicelib.a\" To run the tests: fpm test -- profile release -- flag \"-D HAS_SPICELIB\" -- link - flag \"./toolkit/lib/spicelib.a\" The use the library, SPICELIB is not required. It can be imported like any normal FPM library like so: [dependencies] moonframe = { git = \"https://github.com/jacobwilliams/moonframe.git\" } See the interp_test.f90 for an example of how to use the library. Documentation The latest API documentation for the master branch can be found here . This was generated from the source code using FORD . References “High Accuracy” Orientation and Body-fixed Frames for the Moon and Earth Developer Info Jacob Williams","tags":"home","url":"index.html"},{"title":"moon_frame_interpolater – moonframe ","text":"type, public :: moon_frame_interpolater Main class to read a pre-computed CSV file with roll, pitch, and yaw angles\nand interpolate the angles to get the rotation matrix for a given ephemeris time. Inherits type~~moon_frame_interpolater~~InheritsGraph type~moon_frame_interpolater moon_frame_interpolater bspline_1d bspline_1d type~moon_frame_interpolater->bspline_1d roll_spline, pitch_spline, yaw_x_spline, yaw_y_spline Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type(bspline_1d), private :: roll_spline type(bspline_1d), private :: pitch_spline type(bspline_1d), private :: yaw_x_spline x-component of yaw angle unit vector: x=cos(yaw) type(bspline_1d), private :: yaw_y_spline y-component of yaw angle unit vector: y=sin(yaw) Type-Bound Procedures procedure, public :: initialize => initialize_moon_frame_interpolater private  subroutine initialize_moon_frame_interpolater (me, filename, k, extrapolate, et0, etf) initialize the moon frame interpolater with the given csv file. Arguments Type Intent Optional Attributes Name class( moon_frame_interpolater ), intent(inout) :: me character(len=*), intent(in) :: filename csv file with roll, pitch, and yaw angles vs ephemeris time. (see generate_csv_file ) integer, intent(in), optional :: k spline order ( kx in bspline_module). If not given, use the default quartic order. logical, intent(in), optional :: extrapolate if true, extrapolate the spline outside the range of the data. Default is false. real(kind=wp), intent(in), optional :: et0 start ephemeris time [if not present, the initial time in the file is used] real(kind=wp), intent(in), optional :: etf end ephemeris time [if not present, the final time in the file is used] procedure, public :: destroy => destroy_moon_frame_interpolater private  subroutine destroy_moon_frame_interpolater (me) Arguments Type Intent Optional Attributes Name class( moon_frame_interpolater ), intent(inout) :: me procedure, public :: j2000_to_frame private  function j2000_to_frame (me, et) result(rot) rotation matrix from J2000 to the frame Arguments Type Intent Optional Attributes Name class( moon_frame_interpolater ), intent(inout) :: me real(kind=wp), intent(in) :: et Return Value real(kind=wp), (3,3) procedure, public :: frame_to_j2000 private  function frame_to_j2000 (me, et) result(rot) rotation matrix from the frame to j2000 Arguments Type Intent Optional Attributes Name class( moon_frame_interpolater ), intent(inout) :: me real(kind=wp), intent(in) :: et Return Value real(kind=wp), (3,3) Source Code type , public :: moon_frame_interpolater !! Main class to read a pre-computed CSV file with roll, pitch, and yaw angles !! and interpolate the angles to get the rotation matrix for a given ephemeris time. private type ( bspline_1d ) :: roll_spline type ( bspline_1d ) :: pitch_spline type ( bspline_1d ) :: yaw_x_spline !! x-component of yaw angle unit vector: x=cos(yaw) type ( bspline_1d ) :: yaw_y_spline !! y-component of yaw angle unit vector: y=sin(yaw) contains private procedure , public :: initialize => initialize_moon_frame_interpolater procedure , public :: destroy => destroy_moon_frame_interpolater procedure , public :: j2000_to_frame procedure , public :: frame_to_j2000 end type moon_frame_interpolater","tags":"","url":"type/moon_frame_interpolater.html"},{"title":"j2000_to_frame – moonframe","text":"private  function j2000_to_frame(me, et) result(rot) rotation matrix from J2000 to the frame Type Bound moon_frame_interpolater Arguments Type Intent Optional Attributes Name class( moon_frame_interpolater ), intent(inout) :: me real(kind=wp), intent(in) :: et Return Value real(kind=wp), (3,3) Calls proc~~j2000_to_frame~~CallsGraph proc~j2000_to_frame moon_frame_interpolater%j2000_to_frame evaluate evaluate proc~j2000_to_frame->evaluate proc~rpy_to_rot rpy_to_rot proc~j2000_to_frame->proc~rpy_to_rot Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~j2000_to_frame~~CalledByGraph proc~j2000_to_frame moon_frame_interpolater%j2000_to_frame proc~frame_to_j2000 moon_frame_interpolater%frame_to_j2000 proc~frame_to_j2000->proc~j2000_to_frame Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function j2000_to_frame ( me , et ) result ( rot ) !! rotation matrix from J2000 to the frame class ( moon_frame_interpolater ), intent ( inout ) :: me real ( wp ), intent ( in ) :: et real ( wp ) :: rot ( 3 , 3 ) real ( wp ) :: roll , pitch , yaw_x , yaw_y , yaw integer :: iflag call me % roll_spline % evaluate ( et , 0 , roll , iflag ); if ( iflag /= 0 ) error stop 'error computing roll spline.' call me % pitch_spline % evaluate ( et , 0 , pitch , iflag ); if ( iflag /= 0 ) error stop 'error computing pitch spline.' call me % yaw_x_spline % evaluate ( et , 0 , yaw_x , iflag ); if ( iflag /= 0 ) error stop 'error computing yaw_x spline.' call me % yaw_y_spline % evaluate ( et , 0 , yaw_y , iflag ); if ( iflag /= 0 ) error stop 'error computing yaw_y spline.' yaw = atan2 ( yaw_y , yaw_x ) ! convert to rotation matrix: call rpy_to_rot ( roll , pitch , yaw , rot ) end function j2000_to_frame","tags":"","url":"proc/j2000_to_frame.html"},{"title":"frame_to_j2000 – moonframe","text":"private  function frame_to_j2000(me, et) result(rot) rotation matrix from the frame to j2000 Type Bound moon_frame_interpolater Arguments Type Intent Optional Attributes Name class( moon_frame_interpolater ), intent(inout) :: me real(kind=wp), intent(in) :: et Return Value real(kind=wp), (3,3) Calls proc~~frame_to_j2000~~CallsGraph proc~frame_to_j2000 moon_frame_interpolater%frame_to_j2000 proc~j2000_to_frame moon_frame_interpolater%j2000_to_frame proc~frame_to_j2000->proc~j2000_to_frame evaluate evaluate proc~j2000_to_frame->evaluate proc~rpy_to_rot rpy_to_rot proc~j2000_to_frame->proc~rpy_to_rot Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function frame_to_j2000 ( me , et ) result ( rot ) !! rotation matrix from the frame to j2000 class ( moon_frame_interpolater ), intent ( inout ) :: me real ( wp ), intent ( in ) :: et real ( wp ) :: rot ( 3 , 3 ) rot = transpose ( me % j2000_to_frame ( et )) end function frame_to_j2000","tags":"","url":"proc/frame_to_j2000.html"},{"title":"initialize_moon_frame_interpolater – moonframe","text":"private  subroutine initialize_moon_frame_interpolater(me, filename, k, extrapolate, et0, etf) initialize the moon frame interpolater with the given csv file. Type Bound moon_frame_interpolater Arguments Type Intent Optional Attributes Name class( moon_frame_interpolater ), intent(inout) :: me character(len=*), intent(in) :: filename csv file with roll, pitch, and yaw angles vs ephemeris time. (see generate_csv_file ) integer, intent(in), optional :: k spline order ( kx in bspline_module). If not given, use the default quartic order. logical, intent(in), optional :: extrapolate if true, extrapolate the spline outside the range of the data. Default is false. real(kind=wp), intent(in), optional :: et0 start ephemeris time [if not present, the initial time in the file is used] real(kind=wp), intent(in), optional :: etf end ephemeris time [if not present, the final time in the file is used] Calls proc~~initialize_moon_frame_interpolater~~CallsGraph proc~initialize_moon_frame_interpolater moon_frame_interpolater%initialize_moon_frame_interpolater destroy destroy proc~initialize_moon_frame_interpolater->destroy get get proc~initialize_moon_frame_interpolater->get initialize initialize proc~initialize_moon_frame_interpolater->initialize Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine initialize_moon_frame_interpolater ( me , filename , k , extrapolate , et0 , etf ) !! initialize the moon frame interpolater with the given csv file. class ( moon_frame_interpolater ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: filename !! csv file with roll, pitch, and yaw angles vs ephemeris time. (see `generate_csv_file`) integer , intent ( in ), optional :: k !! spline order (`kx` in bspline_module). If not given, use the default quartic order. logical , intent ( in ), optional :: extrapolate !! if true, extrapolate the spline outside the range of the data. Default is false. real ( wp ), intent ( in ), optional :: et0 !! start ephemeris time [if not present, the initial time in the file is used] real ( wp ), intent ( in ), optional :: etf !! end ephemeris time [if not present, the final time in the file is used] logical :: status_ok type ( csv_file ) :: f real ( wp ), dimension (:), allocatable :: et , roll , pitch , yaw , yaw_x , yaw_y integer :: iflag , i , kx , n logical :: extrap !! extrapolate flag integer :: istart !! first index to use integer :: iend !! last index to use ! optional arguments: if ( present ( k )) then kx = k else kx = bspline_order_quartic end if if ( present ( extrapolate )) then extrap = extrapolate else extrap = . false . end if ! read the data from the csv file: call f % read ( filename , header_row = 1 , status_ok = status_ok ) if (. not . status_ok ) error stop 'error reading file: ' // trim ( filename ) ! get data call f % get ( 1 , et , status_ok ); if (. not . status_ok ) error stop 'error getting et from file: ' // trim ( filename ) call f % get ( 2 , roll , status_ok ); if (. not . status_ok ) error stop 'error getting roll from file: ' // trim ( filename ) call f % get ( 3 , pitch , status_ok ); if (. not . status_ok ) error stop 'error getting pitch from file: ' // trim ( filename ) call f % get ( 4 , yaw , status_ok ); if (. not . status_ok ) error stop 'error getting yaw from file: ' // trim ( filename ) call f % destroy () ! data to use: n = size ( et ) ! number of rows in the file istart = 1 ! by default, use all the data iend = n if ( present ( et0 )) then istart = minloc ( abs ( et - et0 ), 1 ) if ( et ( istart ) > et0 ) istart = max ( 1 , istart - 1 ) end if if ( present ( etf )) then iend = minloc ( abs ( et - etf ), 1 ) if ( et ( iend ) < etf ) iend = min ( n , iend + 1 ) end if if ( et ( iend ) < et ( istart )) error stop 'Error: end time is before start time' ! for the moon frames, roll and pitch have no discontinuities, ! so they can be splined normally. Yaw will go from 0 to 2pi, ! so we need to convert the angle to its vector components and spline those, ! and then convert back to angle when we need it. allocate ( yaw_x ( n )) allocate ( yaw_y ( n )) do i = istart , iend yaw_x ( i ) = cos ( yaw ( i )) yaw_y ( i ) = sin ( yaw ( i )) end do ! initialize the splines: call me % roll_spline % initialize ( et ( istart : iend ), roll ( istart : iend ), kx , iflag , extrap = extrap ) if ( iflag /= 0 ) error stop 'error initializing roll spline: ' // trim ( filename ) call me % pitch_spline % initialize ( et ( istart : iend ), pitch ( istart : iend ), kx , iflag , extrap = extrap ) if ( iflag /= 0 ) error stop 'error initializing pitch spline: ' // trim ( filename ) call me % yaw_x_spline % initialize ( et ( istart : iend ), yaw_x ( istart : iend ), kx , iflag , extrap = extrap ) if ( iflag /= 0 ) error stop 'error initializing yaw_x spline: ' // trim ( filename ) call me % yaw_y_spline % initialize ( et ( istart : iend ), yaw_y ( istart : iend ), kx , iflag , extrap = extrap ) if ( iflag /= 0 ) error stop 'error initializing yaw_y spline: ' // trim ( filename ) deallocate ( et , roll , pitch , yaw , yaw_x , yaw_y ) end subroutine initialize_moon_frame_interpolater","tags":"","url":"proc/initialize_moon_frame_interpolater.html"},{"title":"rpy_to_rot – moonframe","text":"private pure subroutine rpy_to_rot(roll, pitch, yaw, r) roll, patch, yaw to rotation matrix Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: roll rad real(kind=wp), intent(in) :: pitch rad real(kind=wp), intent(in) :: yaw rad real(kind=wp), intent(out) :: r (3,3) Called by proc~~rpy_to_rot~~CalledByGraph proc~rpy_to_rot rpy_to_rot proc~j2000_to_frame moon_frame_interpolater%j2000_to_frame proc~j2000_to_frame->proc~rpy_to_rot proc~frame_to_j2000 moon_frame_interpolater%frame_to_j2000 proc~frame_to_j2000->proc~j2000_to_frame Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine rpy_to_rot ( roll , pitch , yaw , r ) !! roll, patch, yaw to rotation matrix real ( wp ), intent ( in ) :: roll , pitch , yaw !! rad real ( wp ), intent ( out ) :: r ( 3 , 3 ) real ( wp ) :: cr , sr , cp , sp , cy , sy cr = cos ( roll ) sr = sin ( roll ) cp = cos ( pitch ) sp = sin ( pitch ) cy = cos ( yaw ) sy = sin ( yaw ) r ( 1 , 1 ) = cy * cp r ( 1 , 2 ) = cy * sp * sr - sy * cr r ( 1 , 3 ) = cy * sp * cr + sy * sr r ( 2 , 1 ) = sy * cp r ( 2 , 2 ) = sy * sp * sr + cy * cr r ( 2 , 3 ) = sy * sp * cr - cy * sr r ( 3 , 1 ) = - sp r ( 3 , 2 ) = cp * sr r ( 3 , 3 ) = cp * cr end subroutine rpy_to_rot","tags":"","url":"proc/rpy_to_rot.html"},{"title":"destroy_moon_frame_interpolater – moonframe","text":"private  subroutine destroy_moon_frame_interpolater(me) Type Bound moon_frame_interpolater Arguments Type Intent Optional Attributes Name class( moon_frame_interpolater ), intent(inout) :: me Calls proc~~destroy_moon_frame_interpolater~~CallsGraph proc~destroy_moon_frame_interpolater moon_frame_interpolater%destroy_moon_frame_interpolater destroy destroy proc~destroy_moon_frame_interpolater->destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine destroy_moon_frame_interpolater ( me ) class ( moon_frame_interpolater ), intent ( inout ) :: me call me % roll_spline % destroy () call me % pitch_spline % destroy () call me % yaw_x_spline % destroy () call me % yaw_y_spline % destroy () end subroutine destroy_moon_frame_interpolater","tags":"","url":"proc/destroy_moon_frame_interpolater.html"},{"title":"moon_frame_module – moonframe","text":"Module for interpolation of body-fixed Moon frames. Uses iso_fortran_env csv_module bspline_module module~~moon_frame_module~~UsesGraph module~moon_frame_module moon_frame_module bspline_module bspline_module module~moon_frame_module->bspline_module csv_module csv_module module~moon_frame_module->csv_module iso_fortran_env iso_fortran_env module~moon_frame_module->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, private, parameter :: wp = real64 Real working precision if not specified [8 bytes] integer, public, parameter :: moon_frame_wp = wp working precision for moon frame Derived Types type, public :: moon_frame_interpolater Main class to read a pre-computed CSV file with roll, pitch, and yaw angles\nand interpolate the angles to get the rotation matrix for a given ephemeris time. Components Type Visibility Attributes Name Initial type(bspline_1d), private :: roll_spline type(bspline_1d), private :: pitch_spline type(bspline_1d), private :: yaw_x_spline x-component of yaw angle unit vector: x=cos(yaw) type(bspline_1d), private :: yaw_y_spline y-component of yaw angle unit vector: y=sin(yaw) Type-Bound Procedures procedure, public :: initialize => initialize_moon_frame_interpolater procedure, public :: destroy => destroy_moon_frame_interpolater procedure, public :: j2000_to_frame procedure, public :: frame_to_j2000 Functions private  function j2000_to_frame (me, et) result(rot) rotation matrix from J2000 to the frame Arguments Type Intent Optional Attributes Name class( moon_frame_interpolater ), intent(inout) :: me real(kind=wp), intent(in) :: et Return Value real(kind=wp), (3,3) private  function frame_to_j2000 (me, et) result(rot) rotation matrix from the frame to j2000 Arguments Type Intent Optional Attributes Name class( moon_frame_interpolater ), intent(inout) :: me real(kind=wp), intent(in) :: et Return Value real(kind=wp), (3,3) Subroutines private  subroutine initialize_moon_frame_interpolater (me, filename, k, extrapolate, et0, etf) initialize the moon frame interpolater with the given csv file. Arguments Type Intent Optional Attributes Name class( moon_frame_interpolater ), intent(inout) :: me character(len=*), intent(in) :: filename csv file with roll, pitch, and yaw angles vs ephemeris time. (see generate_csv_file ) integer, intent(in), optional :: k spline order ( kx in bspline_module). If not given, use the default quartic order. logical, intent(in), optional :: extrapolate if true, extrapolate the spline outside the range of the data. Default is false. real(kind=wp), intent(in), optional :: et0 start ephemeris time [if not present, the initial time in the file is used] real(kind=wp), intent(in), optional :: etf end ephemeris time [if not present, the final time in the file is used] private pure subroutine rpy_to_rot (roll, pitch, yaw, r) roll, patch, yaw to rotation matrix Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: roll rad real(kind=wp), intent(in) :: pitch rad real(kind=wp), intent(in) :: yaw rad real(kind=wp), intent(out) :: r (3,3) private  subroutine destroy_moon_frame_interpolater (me) Arguments Type Intent Optional Attributes Name class( moon_frame_interpolater ), intent(inout) :: me","tags":"","url":"module/moon_frame_module.html"},{"title":"moon_frame_spice_interface – moonframe","text":"Interface to SPICE library for Moon frame transformations spice uses double precision Uses iso_fortran_env module~~moon_frame_spice_interface~~UsesGraph module~moon_frame_spice_interface moon_frame_spice_interface iso_fortran_env iso_fortran_env module~moon_frame_spice_interface->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: j2000_id = 1 integer, public, parameter :: iau_moon_id = 10020 integer, public, parameter :: moon_me_id = 31001 from the kernel integer, public, parameter :: moon_pa_id = 31000 from the kernel","tags":"","url":"module/moon_frame_spice_interface.html"},{"title":"moon_frame_module.F90 – moonframe","text":"Source Code !*************************************************************************** !> !  Module for interpolation of body-fixed Moon frames. module moon_frame_module use bspline_module use iso_fortran_env use csv_module implicit none private #ifdef REAL32 integer , parameter :: wp = real32 !! Real working precision [4 bytes] #elif REAL64 integer , parameter :: wp = real64 !! Real working precision [8 bytes] #elif REAL128 integer , parameter :: wp = real128 !! Real working precision [16 bytes] #else integer , parameter :: wp = real64 !! Real working precision if not specified [8 bytes] #endif integer , parameter , public :: moon_frame_wp = wp !! working precision for moon frame type , public :: moon_frame_interpolater !! Main class to read a pre-computed CSV file with roll, pitch, and yaw angles !! and interpolate the angles to get the rotation matrix for a given ephemeris time. private type ( bspline_1d ) :: roll_spline type ( bspline_1d ) :: pitch_spline type ( bspline_1d ) :: yaw_x_spline !! x-component of yaw angle unit vector: x=cos(yaw) type ( bspline_1d ) :: yaw_y_spline !! y-component of yaw angle unit vector: y=sin(yaw) contains private procedure , public :: initialize => initialize_moon_frame_interpolater procedure , public :: destroy => destroy_moon_frame_interpolater procedure , public :: j2000_to_frame procedure , public :: frame_to_j2000 end type moon_frame_interpolater contains subroutine initialize_moon_frame_interpolater ( me , filename , k , extrapolate , et0 , etf ) !! initialize the moon frame interpolater with the given csv file. class ( moon_frame_interpolater ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: filename !! csv file with roll, pitch, and yaw angles vs ephemeris time. (see `generate_csv_file`) integer , intent ( in ), optional :: k !! spline order (`kx` in bspline_module). If not given, use the default quartic order. logical , intent ( in ), optional :: extrapolate !! if true, extrapolate the spline outside the range of the data. Default is false. real ( wp ), intent ( in ), optional :: et0 !! start ephemeris time [if not present, the initial time in the file is used] real ( wp ), intent ( in ), optional :: etf !! end ephemeris time [if not present, the final time in the file is used] logical :: status_ok type ( csv_file ) :: f real ( wp ), dimension (:), allocatable :: et , roll , pitch , yaw , yaw_x , yaw_y integer :: iflag , i , kx , n logical :: extrap !! extrapolate flag integer :: istart !! first index to use integer :: iend !! last index to use ! optional arguments: if ( present ( k )) then kx = k else kx = bspline_order_quartic end if if ( present ( extrapolate )) then extrap = extrapolate else extrap = . false . end if ! read the data from the csv file: call f % read ( filename , header_row = 1 , status_ok = status_ok ) if (. not . status_ok ) error stop 'error reading file: ' // trim ( filename ) ! get data call f % get ( 1 , et , status_ok ); if (. not . status_ok ) error stop 'error getting et from file: ' // trim ( filename ) call f % get ( 2 , roll , status_ok ); if (. not . status_ok ) error stop 'error getting roll from file: ' // trim ( filename ) call f % get ( 3 , pitch , status_ok ); if (. not . status_ok ) error stop 'error getting pitch from file: ' // trim ( filename ) call f % get ( 4 , yaw , status_ok ); if (. not . status_ok ) error stop 'error getting yaw from file: ' // trim ( filename ) call f % destroy () ! data to use: n = size ( et ) ! number of rows in the file istart = 1 ! by default, use all the data iend = n if ( present ( et0 )) then istart = minloc ( abs ( et - et0 ), 1 ) if ( et ( istart ) > et0 ) istart = max ( 1 , istart - 1 ) end if if ( present ( etf )) then iend = minloc ( abs ( et - etf ), 1 ) if ( et ( iend ) < etf ) iend = min ( n , iend + 1 ) end if if ( et ( iend ) < et ( istart )) error stop 'Error: end time is before start time' ! for the moon frames, roll and pitch have no discontinuities, ! so they can be splined normally. Yaw will go from 0 to 2pi, ! so we need to convert the angle to its vector components and spline those, ! and then convert back to angle when we need it. allocate ( yaw_x ( n )) allocate ( yaw_y ( n )) do i = istart , iend yaw_x ( i ) = cos ( yaw ( i )) yaw_y ( i ) = sin ( yaw ( i )) end do ! initialize the splines: call me % roll_spline % initialize ( et ( istart : iend ), roll ( istart : iend ), kx , iflag , extrap = extrap ) if ( iflag /= 0 ) error stop 'error initializing roll spline: ' // trim ( filename ) call me % pitch_spline % initialize ( et ( istart : iend ), pitch ( istart : iend ), kx , iflag , extrap = extrap ) if ( iflag /= 0 ) error stop 'error initializing pitch spline: ' // trim ( filename ) call me % yaw_x_spline % initialize ( et ( istart : iend ), yaw_x ( istart : iend ), kx , iflag , extrap = extrap ) if ( iflag /= 0 ) error stop 'error initializing yaw_x spline: ' // trim ( filename ) call me % yaw_y_spline % initialize ( et ( istart : iend ), yaw_y ( istart : iend ), kx , iflag , extrap = extrap ) if ( iflag /= 0 ) error stop 'error initializing yaw_y spline: ' // trim ( filename ) deallocate ( et , roll , pitch , yaw , yaw_x , yaw_y ) end subroutine initialize_moon_frame_interpolater function j2000_to_frame ( me , et ) result ( rot ) !! rotation matrix from J2000 to the frame class ( moon_frame_interpolater ), intent ( inout ) :: me real ( wp ), intent ( in ) :: et real ( wp ) :: rot ( 3 , 3 ) real ( wp ) :: roll , pitch , yaw_x , yaw_y , yaw integer :: iflag call me % roll_spline % evaluate ( et , 0 , roll , iflag ); if ( iflag /= 0 ) error stop 'error computing roll spline.' call me % pitch_spline % evaluate ( et , 0 , pitch , iflag ); if ( iflag /= 0 ) error stop 'error computing pitch spline.' call me % yaw_x_spline % evaluate ( et , 0 , yaw_x , iflag ); if ( iflag /= 0 ) error stop 'error computing yaw_x spline.' call me % yaw_y_spline % evaluate ( et , 0 , yaw_y , iflag ); if ( iflag /= 0 ) error stop 'error computing yaw_y spline.' yaw = atan2 ( yaw_y , yaw_x ) ! convert to rotation matrix: call rpy_to_rot ( roll , pitch , yaw , rot ) end function j2000_to_frame function frame_to_j2000 ( me , et ) result ( rot ) !! rotation matrix from the frame to j2000 class ( moon_frame_interpolater ), intent ( inout ) :: me real ( wp ), intent ( in ) :: et real ( wp ) :: rot ( 3 , 3 ) rot = transpose ( me % j2000_to_frame ( et )) end function frame_to_j2000 pure subroutine rpy_to_rot ( roll , pitch , yaw , r ) !! roll, patch, yaw to rotation matrix real ( wp ), intent ( in ) :: roll , pitch , yaw !! rad real ( wp ), intent ( out ) :: r ( 3 , 3 ) real ( wp ) :: cr , sr , cp , sp , cy , sy cr = cos ( roll ) sr = sin ( roll ) cp = cos ( pitch ) sp = sin ( pitch ) cy = cos ( yaw ) sy = sin ( yaw ) r ( 1 , 1 ) = cy * cp r ( 1 , 2 ) = cy * sp * sr - sy * cr r ( 1 , 3 ) = cy * sp * cr + sy * sr r ( 2 , 1 ) = sy * cp r ( 2 , 2 ) = sy * sp * sr + cy * cr r ( 2 , 3 ) = sy * sp * cr - cy * sr r ( 3 , 1 ) = - sp r ( 3 , 2 ) = cp * sr r ( 3 , 3 ) = cp * cr end subroutine rpy_to_rot subroutine destroy_moon_frame_interpolater ( me ) class ( moon_frame_interpolater ), intent ( inout ) :: me call me % roll_spline % destroy () call me % pitch_spline % destroy () call me % yaw_x_spline % destroy () call me % yaw_y_spline % destroy () end subroutine destroy_moon_frame_interpolater end module moon_frame_module","tags":"","url":"sourcefile/moon_frame_module.f90.html"},{"title":"moon_frame_spice_interface.F90 – moonframe","text":"Source Code !*************************************************************************** !> !  Interface to SPICE library for Moon frame transformations module moon_frame_spice_interface use iso_fortran_env , only : wp => real64 !! spice uses double precision implicit none private ! SPICE IDs integer , parameter , public :: j2000_id = 1 integer , parameter , public :: iau_moon_id = 10020 integer , parameter , public :: moon_me_id = 31001 !! from the kernel integer , parameter , public :: moon_pa_id = 31000 !! from the kernel #ifdef HAS_SPICELIB ! from spicelib: interface subroutine refchg ( frame1 , frame2 , et , rotate ) import implicit none integer :: frame1 integer :: frame2 real ( wp ) :: et real ( wp ) :: rotate ( 3 , 3 ) end subroutine refchg subroutine furnsh ( file ) import implicit none character ( len =* ) :: file end subroutine furnsh subroutine str2et ( timstr , et ) import implicit none character ( len =* ) :: timstr real ( wp ) :: et end subroutine str2et end interface public :: refchg , furnsh , str2et public :: from_j2000_to_iau_moon , from_j2000_to_moon_me , from_j2000_to_moon_pa contains subroutine from_j2000_to_moon_me ( et , rot ) real ( wp ), intent ( in ) :: et real ( wp ), intent ( out ) :: rot ( 3 , 3 ) call refchg ( j2000_id , moon_me_id , et , rot ) end subroutine from_j2000_to_moon_me subroutine from_j2000_to_moon_pa ( et , rot ) real ( wp ), intent ( in ) :: et real ( wp ), intent ( out ) :: rot ( 3 , 3 ) call refchg ( j2000_id , moon_pa_id , et , rot ) end subroutine from_j2000_to_moon_pa subroutine from_j2000_to_iau_moon ( et , rot ) real ( wp ), intent ( in ) :: et real ( wp ), intent ( out ) :: rot ( 3 , 3 ) call refchg ( j2000_id , iau_moon_id , et , rot ) end subroutine from_j2000_to_iau_moon #endif end module moon_frame_spice_interface","tags":"","url":"sourcefile/moon_frame_spice_interface.f90.html"}]}